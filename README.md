# Pac‑Man for LandTiger LPC1768

A classroom-friendly Pac‑Man clone for the Embest/PowerMCU LandTiger LPC1768 development board. It showcases GLCD graphics, joystick input via the Repetitive Interrupt Timer (RIT), timers and NVIC interrupts, simple DAC audio with melodies, and basic CAN telemetry — all in a tidy embedded C codebase built with Keil MDK.

This project started from PowerMCU examples and was adapted to become a mini‑game for teaching microcontroller peripherals and real‑time programming on the LPC1768.

## Highlights

- 240×320 TFT GLCD rendering with tile‑based map and sprites
- Joystick controls via RIT scan; external button toggles Pause/Start
- 1 playable character (Pac‑Man) + 1 ghost with A\* pathfinding
- Power pills that make the ghost flee for a limited time
- Scoring, lives, and a 60‑second game timer
- Simple DAC audio (background, win, lose, pill sounds)
- Optional CAN telemetry broadcast (score, lives, timer)

## Hardware

Designed for the LandTiger LPC1768 board (NXP LPC1768, Cortex‑M3) featuring:

- 3.2" TFT LCD (ILI9325/SSD1289 and similar supported by the provided GLCD driver)
- On‑board joystick and buttons
- On‑board speaker/buzzer (driven by LPC_DAC)
- Optional CAN transceiver connected to CAN1

Notes

- The GLCD driver in `Source/GLCD` supports several controller IDs (ILI9325/28, SSD1289/1298, etc.). The LandTiger’s panel should be auto‑detected at init.
- CAN is optional; if a CAN transceiver and bus are not present, the game still runs without telemetry.

## Toolchain and project files

- IDE: Keil MDK (uVision 5)
- Project file: `sample.uvprojx`
- Targets: multiple uVision targets are included (e.g., `LandTiger_LPC1768`, `LandTiger_LPC1768__release_`, `SW_DEBUG`, `uu`). Pick the one that matches your setup.
- CMSIS is included under `Source/CMSIS_core`.

## Build, flash, and run

1. Open `sample.uvprojx` in Keil uVision.
2. Select the desired Target (e.g., `LandTiger_LPC1768`).
3. Build the project (Project > Build target).
4. Connect your ULINK (or other supported debug probe) to the LandTiger.
5. Flash and run (Debug > Start/Stop Debug Session, then Run), or use the Download button.

Simulation

- You can also run in the Keil simulator. Define the `SIMULATOR` symbol for the target if needed; some code paths check this define.

## Controls and gameplay

Startup

- On reset you’ll see the maze with “PAUSE” in the center, a 60s countdown on the left, and score on the right.

Controls (joystick on P1.25–P1.29)

- Up/Down/Left/Right move Pac‑Man when the game is running
- INT0 (EINT0 on P2.10) toggles Pause ↔ Start (also used to acknowledge Win/Lose)

Rules and scoring

- Standard pill: +10 points (small green dot)
- Power pill: +50 points (bigger red dot); ghost becomes edible/fleeing for ~10 seconds
- Eating a fleeing ghost: +100 points; it respawns after a short delay
- Extra life every +1000 points
- You win at 2640 points; you lose if lives reach 0 or the 60‑second timer hits 0

Difficulty pacing

- The ghost speeds up as your score increases (4 steps across the 0–2640 range).

Ghost behaviour

- Chase: A\* pathfinding (Manhattan heuristic) toward Pac‑Man
- Flee: an “escape” variant that moves away from Pac‑Man and favors the farthest valid move

Teleport tunnels

- The map includes left/right tunnels that wrap Pac‑Man across the maze edges.

## CAN telemetry (optional)

The game periodically broadcasts a short status frame on CAN1 (Standard frame, ID 0x2):

- Byte 0–1: score (two bytes; implementation packs high/low bytes in code)
- Byte 2: lives
- Byte 3: remaining time (seconds)

You can hook a CAN analyzer or another node to visualize live gameplay stats.

## Project layout

Top‑level

- `sample.uvprojx`, `sample.uvoptx`, `sample.uvguix.*`: Keil MDK project files and user settings
- `DebugConfig/`: debug probe configurations
- `Listings/`, `Objects/`: build outputs (generated by uVision)
- `RTE/`: runtime environment headers per target

Source tree (key parts)

- `Source/sample.c`: entry point; initializes clocks, peripherals, screen, timers, and starts RIT
- `Source/GLCD/`: LCD driver and basic 2D drawing primitives
  - `GLCD.c`: low‑level LCD driver, plus the game map (`mapMatrix`), ghost map, sprite bitmaps, and utilities to draw the maze and items
  - `GLCD.h`: driver API + game constants (tile codes, directions, game states)
- `Source/PacMan/`:
  - `matrixManager.c/.h`: game logic — player/ghost structs, movement, collision, scoring, lives, A\* pathfinding, and “flee” logic
- `Source/RIT/`:
  - `IRQ_RIT.c`: reads joystick/buttons each tick; handles pause/start and menu/background melodies
  - `lib_RIT.c`, `RIT.h`: RIT setup helpers
- `Source/timer/`:
  - `lib_timer.c`, `IRQ_timer.c`, `timer.h`: timer setup and periodic handlers for movement, countdown, audio, and CAN
- `Source/music/`:
  - `music.h` (+ `music.c`): note tables, durations, and simple DAC playback helpers
- Other peripherals (present, some optional for gameplay):
  - `button_EXINT/`: external button IRQs
  - `joystick/`: joystick init helpers
  - `CAN/`: CAN init and transmit
  - `adc/`: ADC init (not central to gameplay)
  - `TouchPanel/`: touch driver (not used in the current game loop)
  - `CMSIS_core/`, `startup_LPC17xx.s`, `system_LPC17xx.c`: device support and startup

## Configuration knobs

- Game map: edit `mapMatrix` in `Source/GLCD/GLCD.c` to change the maze; tiles are 10×10 pixels on a 24×26 grid (offset by 3 rows on screen)
- Sprites: `pacmanMatrix` and `ghostMatrix` in `GLCD.c`
- Music tempo: `SPEEDUP`, `UPTICKS` in `Source/music/music.h`
- Timer cadence: `init_timer` calls in `Source/sample.c`; timer ISR logic in `Source/timer/IRQ_timer.c`
- Initial timer value and states: `initPlayerPos` in `Source/PacMan/matrixManager.c`

## Known limitations

- Only the red ghost is active; scaffolding for additional ghosts is present but commented out
- Touch panel and ADC are initialized in the project but not used in core gameplay
- Some comments originate from the vendor examples and are not fully localized

## Acknowledgements

- Based on and adapted from PowerMCU/Embest example code for the LandTiger board
- Course modifications and gameplay logic by Paolo Bernardi and contributors

## License

No explicit license file is included. If you plan to distribute or reuse this code, consider adding a `LICENSE` file clarifying terms.
